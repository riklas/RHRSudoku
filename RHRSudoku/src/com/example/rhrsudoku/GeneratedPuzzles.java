package com.example.rhrsudoku;


import java.util.ArrayList;
import java.util.Random;

import exactCover.Quant;

public class GeneratedPuzzles implements SudokuGenerator {

	SudokuPuzzle puzzle = new SudokuPuzzle();
	SudokuSolver solver = new SudokuSolver();
	Quant currentSolutions;
	int value = 0;
	int ceilingCount;
	int floorCount;
	
	
	public GeneratedPuzzles() {
	}

	@Override
	public SudokuPuzzle getPuzzle(int difficulty) {
		switch(difficulty) {
		case 0: floorCount = 32; 
				ceilingCount = 40;
				break;
		case 1: floorCount = 28; 
				ceilingCount = 32;
				break;
		case 2: floorCount = 22; 
				ceilingCount = 25;
				break;
		case 3: floorCount = 18; 
				ceilingCount = 22;
				break;
		default:floorCount = 32; 
				ceilingCount = 40;
				break;
		}
		
		
		
		puzzle.printPuzzle();
		//this returns a solved puzzle
		puzzle = solver.solvePuzzle(puzzle);		
		puzzle.printPuzzle();
		//this returns puzzle with values taken out
		puzzle = setValues(puzzle);
		return puzzle;
	}

	
	public SudokuPuzzle setValues(SudokuPuzzle targetPuzzle) {
		
		targetPuzzle = removeValue(targetPuzzle);
		
		// set the input method 
		for(int row=0; row<9; row++) {
			for(int column=0; column<9; column++) {
				if (targetPuzzle.puzzle[row][column].hasValue) {
					targetPuzzle.puzzle[row][column].setInput(SudokuPuzzleCell.GENERATED); //set input method as generated
				}
			}
		}
		
		return targetPuzzle;
	}
	
	public SudokuPuzzle removeValue(SudokuPuzzle targetPuzzle) {
		System.out.println("floor count " + floorCount);
		System.out.println("ceiling count " + ceilingCount);
		
		Quant numSolutions;
		int randx;
		int randy;
		int prevCount = 81;		//this stores the value 'numlock' loops ago 
		int loopCount = 0;	// counts the number of loops
		int numlock = 75;
		Quant numComparison = Quant.ONE;
		int counter = 81;	// the number of values in puzzle		
		Random randomGenerator = new Random();
		
		while (true) {
			do {
				randx = randomGenerator.nextInt(9);	//generates random number from 0 - 8
				randy = randomGenerator.nextInt(9);	// generates random number from 0 - 8
				if (targetPuzzle.puzzle[randx][randy].hasValue) {					
					value = targetPuzzle.puzzle[randx][randy].getValue();	//saves the value from the index of random number
					targetPuzzle.puzzle[randx][randy].isEditable = true;	//isEditable was set false after being generated by solver
					targetPuzzle.puzzle[randx][randy].removeValue();  // set the value at index to 0
					targetPuzzle.puzzle[randx][randy].setInput(SudokuPuzzleCell.NONE); //set input method to none								
					counter--;							//1 less value in the puzzle
				}			
				numSolutions = solver.solutionsM(targetPuzzle);	//see the number solutions with the value taken out
				
				targetPuzzle.printPuzzle();			////if the number of values left in puzzle go less than the lower bound (specified by difficulty), 
				System.out.println("Counter: " + counter);
				loopCount++;
				if (counter < floorCount) break;	//then stop removing values regardless of the numSolutions
				
				if (loopCount%numlock == 0) {
					int number = prevCount - counter;
					if (number < 0) number = -number;
					if (number < 3) {
						numComparison = Quant.MULTIPLE;
						System.out.println("STUCK IN LOOP! Creating multi-sol puzzle");						
					}
					else
						prevCount = counter;
				}
				
			}
			while (numSolutions == Quant.ONE || numSolutions == numComparison); // if there is 1 solution left do it again
			
			targetPuzzle.puzzle[randx][randy].setValue(value);	// put the last value back
			System.out.println("Putting back: " + value + "coordinates[" + randx + "," + randy + "]");					
			counter++;
			
			
			if (counter > ceilingCount) {		//if the values (specified by count) have not reached the upperbound. don't return			
				continue;			
			}	
			else break;				//only break when number of values is <= count
		}
				
		
		System.out.println("counter: " + counter);
		return targetPuzzle;	//return the puzzle
		}			
};

